<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>MySQL on rustWood</title>
        <link>https://rusthx.github.io/tags/mysql/</link>
        <description>Recent content in MySQL on rustWood</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>rustWood</copyright>
        <lastBuildDate>Fri, 24 Jan 2025 22:23:10 +0800</lastBuildDate><atom:link href="https://rusthx.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySQL主从复制</title>
        <link>https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
        <pubDate>Fri, 24 Jan 2025 22:23:10 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
        <description>&lt;p&gt;主从复制可以用来做数据库的实时备份，保证数据的完整性；也可以做读写分离，提升数据库系统整体的读写性能。&lt;/p&gt;
&lt;h2 id=&#34;主从复制原理&#34;&gt;主从复制原理
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0
&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/2.png&#34;
	width=&#34;960&#34;
	height=&#34;405&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/2_hu12276740477023013187.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/2_hu11267129864193341543.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;568px&#34;
	
&gt;
MySQL集群的主从复制过程梳理成3个阶段：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。&lt;/li&gt;
&lt;li&gt;同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。&lt;/li&gt;
&lt;li&gt;回放 Binlog：回放 binlog，并更新存储引l擎中的数据。
具体详细过程如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 主库在收到客户端提交事务的请求之后，会先写入binlog，再提交事务，更新存储引擎中的数
据，事务提交完成后，返回给客户端&amp;quot;操作成功&amp;quot;的响应。&lt;/li&gt;
&lt;li&gt;从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把
binlog 信息写入 relay log 的中继日志里，再返回给主库&amp;quot;复制成功&amp;quot;的响应。&lt;/li&gt;
&lt;li&gt;从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中
的数据，最终实现主从的数据一致性。
在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者
锁记录，也不会影响读请求的执行。
&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/3.png&#34;
	width=&#34;612&#34;
	height=&#34;607&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/3_hu14524736388878011446.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/3_hu12211041723728468306.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;主从复制配置&#34;&gt;主从复制配置
&lt;/h2&gt;&lt;h3 id=&#34;前置工作&#34;&gt;前置工作
&lt;/h3&gt;&lt;p&gt; 在两台机上分别安装MySQL,相关教程可查看我的相关博客&lt;a class=&#34;link&#34; href=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ubuntu22.04安装MySQL8.0.35&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1.png&#34;
	width=&#34;1074&#34;
	height=&#34;906&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1_hu9957867129983456533.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1_hu13404604853172762023.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;118&#34;
		data-flex-basis=&#34;284px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;hadoop1和hadoop2两台机上都将安装好MySQL，然后hadoop1将作为主节点，hadoop2将作为从节点。主节点提前创建用户用来进行主从连接。注意要给&lt;code&gt;slave&lt;/code&gt;权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;CREATE USER &#39;rust&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
GRANT REPLICATION SLAVE ON *.* TO &#39;rust&#39;@&#39;%&#39; WITH GRANT OPTION;
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改配置文件&#34;&gt;修改配置文件
&lt;/h3&gt;&lt;p&gt;修改主库配置文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo gedit /etc/mysql/my.cnf
# 也可以通过vim修改，命令如下。
#sudo vim /etc/mysql/my.cnf

# 添加如下内容
[mysqld]

server-id = 1
log-bin=mysql-bin
binlog_format=row #这一行可省略，因为MySQL在5.7.7开始的默认值就是row了

binlog-do-db=master_try #用来主从复制的数据库。需要提前创建
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/4.png&#34;
	width=&#34;1142&#34;
	height=&#34;796&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/4_hu17169091789042476138.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/4_hu11920911155031730745.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;修改后保存重启生效。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl restart mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改从库配置文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[mysqld]
server-id=2 # 从数据库的唯一标识符，通常大于主数据库的server-id
relay-log=mysql-relay-bin # 启用中继日志，用于在从数据库上复制主数据库的操作
read-only=1 # 设置从数据库为只读，防止在从数据库上直接写入数据
enforce_gtid_consistency = ON
gtid_mode = ON
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/5.png&#34;
	width=&#34;1288&#34;
	height=&#34;672&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/5_hu13300301466352054486.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/5_hu5035409371873853278.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;460px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;登录从库连接到主库&#34;&gt;登录从库，连接到主库
&lt;/h3&gt;&lt;p&gt;登录主库，查看所需信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -p
show master status;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/6.png&#34;
	width=&#34;1031&#34;
	height=&#34;590&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/6_hu6635927571981079756.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/6_hu14305490593648961526.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;419px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;登录从库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -p                                  #登录mysql
CHANGE MASTER TO MASTER_HOST=&#39;192.168.146.161&#39;,  #指向主库             
MASTER_USER=&#39;rust&#39;,                              #用于复制的MySQL账户,需要提前给定权限
MASTER_PASSWORD=&#39;123456&#39;,                        #密码
MASTER_LOG_FILE=&#39;mysql-bin.000093&#39;,              #主库bin log名称，主库上用SHOW MASTER STATUS查看
MASTER_LOG_POS=197;                              #主库bin log位置，主库上用SHOW MASTER STATUS查看
                      
START SLAVE;                                     #启动从库进程
SHOW SLAVE STATUS\G;                             #显示进程状态

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/7.png&#34;
	width=&#34;973&#34;
	height=&#34;754&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/7_hu14326689744804357760.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/7_hu13688712789841800896.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;309px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/8.png&#34;
	width=&#34;1293&#34;
	height=&#34;885&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/8_hu18223804750484652481.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/8_hu6435194916313471316.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;350px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;注意这里一定要出现两个Yes才行。&lt;/p&gt;
&lt;h3 id=&#34;测试&#34;&gt;测试
&lt;/h3&gt;&lt;p&gt;登录主库，建表插入如下数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;use master_try;
create table student(
    `id` int auto_increment primary key,
    `name` varchar(50),
    `age` int
);

insert into student(id,`name`,age) values (&#39;1&#39;,&#39;姬丝秀忒·雅赛劳拉莉昂·刃下心&#39;,&#39;598&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/9.png&#34;
	width=&#34;1016&#34;
	height=&#34;347&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/9_hu5200674971078331333.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/9_hu3142568949465835453.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;292&#34;
		data-flex-basis=&#34;702px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;登录从库，查看建表及插入情况。
&lt;img src=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/10.png&#34;
	width=&#34;1294&#34;
	height=&#34;829&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/10_hu10252075385053311553.png 480w, https://rusthx.github.io/p/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/10_hu14866522803788232565.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;374px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;同步成功，完成主从复制搭建。&lt;/p&gt;
&lt;h3 id=&#34;踩坑与备注&#34;&gt;踩坑与备注
&lt;/h3&gt;&lt;h3 id=&#34;slave_io_runningno&#34;&gt;slave_io_running：no
&lt;/h3&gt;&lt;p&gt; 这是因为从库连接主库填写的信息有误，比如log_file和pos。补救方法，在从库执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stop slave;

reset slave all;

#再执行一遍正确的连接主库命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从库show-slave-statusg正常但查看不到主库数据&#34;&gt;从库show slave status\G;正常，但查看不到主库数据
&lt;/h3&gt;&lt;p&gt; 这种是主库建的数据库和主库配置文件开启的数据库不同导致的，也就是说主库没有建立配置文件里的数据库。
（我呆得不行，主库配置文件里写的master_try，结果我建表转眼就建成mastertry。查不到数据我还以为是权限的问题，走了好多弯路）&lt;/p&gt;
&lt;!-- ### MySQL新版本相关命令已改变
&gt;参考：https://www.cnblogs.com/architectforest/p/18429705

1. show master status; 不能用了
```shell
# mysql 8.4版本前使用这条命令查看
show master status; 

# MySQL 8.4版本后使用这条命令查看
SHOW BINARY LOG STATUS;
```
2. change master to不能用了
```shell
# MySQL 8.23前
CHANGE MASTER TO MASTER_HOST=&#39;192.168.6.133&#39;, MASTER_USER=&#39;remote&#39;, MASTER_PASSWORD=&#39;yourpassword&#39;, MASTER_LOG_FILE=&#39;binlog.000003&#39;, MASTER_LOG_POS=158;
​
# MySQL 8.23后
CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#39;192.168.6.133&#39;, SOURCE_USER=&#39;remote&#39;, SOURCE_PASSWORD=&#39;yourpassword&#39;, SOURCE_LOG_FILE=&#39;binlog.000003&#39;, SOURCE_LOG_POS=158;
​
CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#39;192.168.6.136&#39;, SOURCE_USER=&#39;remote&#39;, SOURCE_PASSWORD=&#39;yourpassword&#39;, SOURCE_LOG_FILE=&#39;binlog.000004&#39;, SOURCE_LOG_POS=158,GET_SOURCE_PUBLIC_KEY=1;
```
3. start slave不能用了
```shell
# 开启同步
start replica ; #8.0.22之后 
start slave ; #8.0.22之前
```
4. show slave status不能用了
```shell
# 查看状态,\G表示行转列，便于查看
show replica status\G ; #8.0.22之后 
show slave status\G ; #8.0.22之前
``` --&gt;
</description>
        </item>
        <item>
        <title>数据库死锁</title>
        <link>https://rusthx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81/</link>
        <pubDate>Sun, 13 Oct 2024 21:32:40 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81/</guid>
        <description>&lt;h2 id=&#34;定义&#34;&gt;定义
&lt;/h2&gt;&lt;p&gt; 数据库死锁是在多个事务执行过程中发生的一种状态，其中每个事务都在等待其他事务释放它们需要的资源，而这些资源又被其他事务占用。这种相互等待的情况导致事务无法继续执行，因为没有任何事务能够获取它们所需的全部资源来完成操作。&lt;/p&gt;
&lt;h2 id=&#34;死锁死循环四要素&#34;&gt;死锁死循环四要素
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。&lt;/li&gt;
&lt;li&gt;请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。&lt;/li&gt;
&lt;li&gt;不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。&lt;/li&gt;
&lt;li&gt;环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;死锁避免方案&#34;&gt;死锁避免方案
&lt;/h2&gt;&lt;p&gt;数据库管理系统通常会实现死锁检测和解决机制。当检测到死锁时，系统会选择一个事务进行回滚，以解除死锁状态。选择回滚哪个事务通常基于事务的复杂度，系统会尽量选择代价最小的事务进行回滚。&lt;/p&gt;
&lt;p&gt;为了避免死锁，可以采取以下措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保持一致的加锁顺序：确保所有事务都以相同的顺序请求锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少锁的持有时间：尽快完成事务操作并释放锁，避免长时间持有锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用锁超时：设置锁的超时时间，超时后事务自动回滚，释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检测死锁并重试：在应用程序中捕获死锁异常，并实现重试机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>MySQL Join介绍与优化</title>
        <link>https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
        <pubDate>Thu, 12 Sep 2024 23:32:36 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h2 id=&#34;分类&#34;&gt;分类
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;join&lt;/code&gt;有如下种类&lt;/p&gt;
&lt;p&gt;(inner) join&lt;/p&gt;
&lt;p&gt;left (outer) join&lt;/p&gt;
&lt;p&gt;right (outer) join&lt;/p&gt;
&lt;p&gt;cross join :笛卡尔积，与inner join不指定on等效&lt;/p&gt;
&lt;p&gt;straight_join :效果等同于inner join，只是指定左表为驱动表&lt;/p&gt;
&lt;p&gt;full (outer) join :全外连接，MySQL中不支持。可用left join union right join 实现。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select t1.*
  from t1 full join t2 
    on t1.id =t2.id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在MySQL中可以用下列方式实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;select t1.*
  from t1 left join t2 
    on t1.id =t2.id
union
select t1.*
  from t1 right join t2 
    on t1.id =t2.id
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;驱动表与被驱动表&#34;&gt;驱动表与被驱动表
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;inner join&lt;/code&gt; :由驱动器决定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;left join&lt;/code&gt; :左表为驱动表，右表为被驱动表&lt;/p&gt;
&lt;p&gt;&lt;code&gt;right join&lt;/code&gt; :左表为驱动表，右表为被驱动表&lt;/p&gt;
&lt;p&gt;&lt;code&gt;straight_join&lt;/code&gt; :固定左表为驱动表，右表为被驱动表&lt;/p&gt;
&lt;h2 id=&#34;join执行流程&#34;&gt;join执行流程
&lt;/h2&gt;&lt;p&gt;每次取驱动表一行数据，去和被驱动表匹配，即双重for循环&lt;/p&gt;
&lt;h2 id=&#34;join执行的实现方式&#34;&gt;join执行的实现方式
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Nest Loop Join(NLJ)&lt;/code&gt;:单纯的双层循环&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Block Nest Loop Join(BNLJ)&lt;/code&gt;:在NLJ的基础上，利用Join Buffer，一次取出一批驱动表数据，可以减少循环匹配次数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Index Nest Loop Join(INLJ)&lt;/code&gt;:在NLJ的基础上，利用被驱动表连接字段的索引直接找到匹配数据，可以减少循环次数&lt;/p&gt;
&lt;h2 id=&#34;小表驱动大表&#34;&gt;小表驱动大表
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1ms4y177mr/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=2db7c64d895a2907954a5b8725db55d5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1ms4y177mr/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=2db7c64d895a2907954a5b8725db55d5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小表驱动大表是一种常见的SQL优化手段，其原因如下：
 两表关联时会产生一个&lt;code&gt;Join Buffer(关联缓存区)&lt;/code&gt;。&lt;code&gt;Join Buffer&lt;/code&gt;是优化器用于处理连接查询操作时的临时缓冲区，简单来说当需要比较两个或多个表的数据进行Join操作时，&lt;code&gt;JOin Buffer&lt;/code&gt;可以帮助MySQL临时存储结果，以减少磁盘读取和CPU负担，提高查询效率。需要注意的是每个join都有一个单独的缓冲区。&lt;/p&gt;
&lt;p&gt; BNLJ会将驱动表数据加载到Join Buffer里，然后再批量与被驱动表进行匹配，如果驱动表数据流量较大，Join Buffer无法一次性装载驱动表的结果集，将会分阶段与被驱动表进行批量数据匹配，然后记录结果并将结果返回。如果数据量过大，Join Buffer无法一次性加载完成就会分阶段匹配，增大了磁盘读取，降低了效率&lt;/p&gt;
&lt;p&gt;所以总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小表可以被完全加载到内存（Join Buffer）中：
小表的数据量相对较少，可以被完整加载到内存中，减少了磁盘IO的开销。而大表的数据量较大，可能无法完全加载到内存，需要进行磁盘IO操作，会导致性能下降。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少了数据传输量：
将小表作为驱动表可以先获取小表的结果集，再根据小表的结果集进行大表的关联查询。这样可以减少传输到被驱动表的数据量，减少网络传输的开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用索引优化(INLJ)：
MySQL的查询优化器通常会选择使用索引来优化关联查询。将小表作为驱动表可以更好地利用索引，因为小表的索引更容易被缓存并快速定位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;join-on&#34;&gt;join on
&lt;/h2&gt;&lt;p&gt;on后跟连接条件，一般必须指定，且只对被驱动表有效，即使对驱动表加了过滤条件，该条件也无效。&lt;/p&gt;
&lt;p&gt;所以，在join on之后，驱动表包含全部数据，被驱动表只包含on条件过滤后的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：inner join 后的数据只会是下面两个椭圆的交集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/1.png&#34;
	width=&#34;348&#34;
	height=&#34;221&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/1_hu17217040643776161663.png 480w, https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/1_hu12072442993451356462.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;157&#34;
		data-flex-basis=&#34;377px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;on和where&#34;&gt;on和where
&lt;/h2&gt;&lt;p&gt;on 在join时就会过滤数据，而where是join完成后再对数据进行过滤，所以on比where先作用。&lt;/p&gt;
&lt;p&gt;所以，理论上过滤条件放在on后比放在where后性能更好，因为这样可以有更少的数据进入&lt;code&gt;磁盘IO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是，由于on后的条件只对被驱动表有效，过滤条件放在on后和where后的结果可能会不一致，所以谨慎在on后加驱动表的过滤条件。&lt;/p&gt;
&lt;p&gt;对于inner join，on和where就没有区别了&lt;/p&gt;
&lt;h2 id=&#34;多表关联查询优化&#34;&gt;多表关联查询优化
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加过滤条件要想清楚，先对被驱动表过滤还是join完后再一起过滤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量小表驱动大表，这是针对left join和right join的情况，inner join会由优化器自行选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;explain分析SQL语句得到的执行计划的第一行即是驱动表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化join思路：一切为了减少join 时驱动表匹配被驱动表时的循环次数。如果join后的数据量很大，并且还要进行聚合操作，在不影响查询结果的情况下可以考虑先聚合出临时表再进行join&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少单表数据量，如水平分表、垂直分表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态的数据可以在后端进行缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;补充分表设计&#34;&gt;补充：分表设计
&lt;/h2&gt;&lt;p&gt;分表原理：一个大表按照一定的规则分解成多张具有独立存储空间的实体表。这些表可以分布在同一块磁盘上，也可以在不同的磁盘上。&lt;/p&gt;
&lt;p&gt;通过分表实现用户在访问数据时，因不同的条件而访问不同的表，将数据分散在各个实体表中，减少单表的访问压力，提升数据查询效率&lt;/p&gt;
&lt;h3 id=&#34;水平分表&#34;&gt;水平分表
&lt;/h3&gt;&lt;p&gt; 以字段为依据，按照一定的策略，使用hash、range、list等方式将一个表的数据拆分成多个相同结构的表中。
水平分表是为了降低单表的数据量，解决单表的热点问题。&lt;/p&gt;
&lt;p&gt; 比如按时间特性进行划分，将表数据分成历年数据表或者历史数据表（已完成）+在线数据表（正在进行）。
水平分表后的表通过union能还原回原来的表。
&lt;img src=&#34;https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/2.png&#34;
	width=&#34;691&#34;
	height=&#34;481&#34;
	srcset=&#34;https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/2_hu10095678336687076858.png 480w, https://rusthx.github.io/p/mysql-join%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BC%98%E5%8C%96/2_hu18269138479022757295.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;垂直分表&#34;&gt;垂直分表
&lt;/h3&gt;&lt;p&gt; 根据字段查询频率将表中数据拆分为不同结构的表（主表和扩展表）。
例如将热点数据和非热点数据分块存储，这样在查询热点数据时就能将数据缓存起来，减少了随机读取&lt;code&gt;IO&lt;/code&gt;，提高了命中率。
适用于由于字段较多引起数据量和访问量较大的情况，且每个业务场景只访问部分字段。&lt;/p&gt;
&lt;p&gt; 例如：用户对商品感兴趣才会查看详细描述，而详细描述占用存储较多（Text）,可以将该字段垂直分割
垂直分表后的表通过join可以还原回原来的表&lt;/p&gt;
&lt;p&gt;垂直分表的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同的业务场景访问不同的内容，数据量小，提升性能&lt;/li&gt;
&lt;li&gt;集成中数据传输量小&lt;/li&gt;
&lt;li&gt;不同业务场景业务量访问频率不一样，表的操作更新可以更加灵活地控制&lt;/li&gt;
&lt;li&gt;降低业务耦合度&lt;/li&gt;
&lt;li&gt;垂直分割可使行数据变小，一个数据块就能存更多数据，在查询时可以有效减少&lt;code&gt;IO&lt;/code&gt;次数。垂直分表可以有效利用Cache&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;分区分表对比&#34;&gt;分区分表对比
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;定义：分区是在一张表中，根据某种规则将数据分散到不同的物理存储区域。分表则是将一张大表拆分成多张小表。&lt;/li&gt;
&lt;li&gt;数据访问：在分区中，用户无需知道数据在哪个分区，可以像访问普通的表一样访问数据，但在分表中，用户必须先知道数据在哪张表中才能访问到所需数据&lt;/li&gt;
&lt;li&gt;适用场景：分区适用于数据量大，但查询范围有限的场景，而分表适用于数据量大，查询范围广的场景。&lt;/li&gt;
&lt;li&gt;性能：分区可以提高查询性能，因为查询只需要在一个分区内进行（过滤条件使用了分区字段），而不是在整张表中。分表可以提高整体性能，因为每个表的数据量都变少了&lt;/li&gt;
&lt;li&gt;管理：分区可以减少数据的恢复。分表可以使每个表的大小更容易得到控制&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;广播表与分布式表&#34;&gt;广播表与分布式表
&lt;/h2&gt;&lt;p&gt;广播表：小表广播功能能提高跨库场景的性能和简化跨库场景的开发。
将需要广播的数据推送到目标库，冗余了表数据，方便在库内关联查询。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;create table config(
    id int primary key,
    config_key varchar(255),
    config_value varchar(255)
)broadcast;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分布式表：分布式表是指其数据根据某种分片策略在分布式数据库系统的不同节点上。
数据被分成多个分段，每个分段存储在不同的节点上。
分布式表的分布策略可以基于hash、range、list等方式。
分布式表适用于数据量大且需要水平扩展的场景.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;create table users(
    user_id int primary key,
    uname varchar(255),
    email varchar(255)
)distributed by hash(user_id);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;反范式&#34;&gt;反范式
&lt;/h2&gt;&lt;p&gt;属性冗余：在一个表中除了存储关联表的主键外，将关联表的非键字段也存储到此表的处理方式。
有点像垂直分表的反向操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(user_id check_date score),(user_id user_name telephone)
-&amp;gt;
(user_id check_date score user_name telephone)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;级联属性冗余：多表关联时，A关联B,B关联C。在查询时需要同时获取A、B、C三个表的属性或以它们的属性进行条件过滤
，为了减少表关联以提高性能，可以考虑在B表中冗余需要访问的C表字段，减少频繁的表关联操作。&lt;/p&gt;
&lt;p&gt;例如：在员工表中冗余部门表的信息（部门id 部门名称 部门负责人）&lt;/p&gt;
&lt;p&gt;表冗余：针对数据记录进行冗余，即A表的数据复制多份，或者多表关联的结果数据存储成一张表。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接复制：“广播表模式”，可以提高跨库访问的性能&lt;/li&gt;
&lt;li&gt;加工派生：冗余的数据是源表加工后的数据或多表关联的结果&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>MySQL 索引</title>
        <link>https://rusthx.github.io/p/mysql-%E7%B4%A2%E5%BC%95/</link>
        <pubDate>Thu, 12 Sep 2024 23:05:47 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/mysql-%E7%B4%A2%E5%BC%95/</guid>
        <description>&lt;p&gt;我写的这篇博客只是我学习的一点总结，并不系统，也不全面。想要学习较为全面的知识可以看 &lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;小林coding的图解MySQL&lt;/a&gt;相关部分&lt;/p&gt;
&lt;h2 id=&#34;密集列索引&#34;&gt;密集列索引
&lt;/h2&gt;&lt;p&gt;密集列，是指一张表上列的数据没有离散度，列的取值范围较小，高度集中在少数几个值中（如性别）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般来说，密集列由于没有离散度，不适合作为索引列。使用这类密集索引的实际效率可能会低于全表扫描。但是，假如密集列的倾斜度很高时，例如有一个状态列表示是否停用，大部分对象都为停用，那么就可用使用密集列作为索引&lt;/li&gt;
&lt;li&gt;需要保证要查询的数据分布较少，（低于总数据量的5%）。同时还要确定是否有为这一个查询单独优化的需要，因为索引也会占用空间，建太多索引反而会降低查询效率，甚至会出现加了索引，查询效率反而变慢的情况。优化并不是将每个查询都单独优化到1s内，而是衡量损失后在妥协中得到一个平衡，让慢查询只占很少比例，优先保证查询次数多的语句。&lt;/li&gt;
&lt;li&gt;可能会频繁变更的列不宜作为索引列，因为索引列变更会导致索引重排，也即是B+树的树结构变更。这会导致修改效率大幅下降&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;索引合并index_merge&#34;&gt;索引合并(index_merge)
&lt;/h2&gt;&lt;p&gt;当数据过滤条件分布在多个索引列上时（无论是&lt;code&gt;and&lt;/code&gt;还是&lt;code&gt;or&lt;/code&gt;），MySQL为了提升数据访问效率会使用多个索引合并的方式过滤数据。、&lt;/p&gt;
&lt;p&gt;索引合并会导致单个索引过滤的数据量越大，查询效率下降越明显&lt;/p&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁
&lt;/h2&gt;&lt;p&gt;MySQL的行锁是通过对索引加锁来实现的。数据修改时会根据过滤条件匹配对应的索引，在对应的索引上加锁。如果语句中修改了索引的值，就还会在修改后的值上加锁。其他事务使用相同的索引值修改数据不管是否是相同的行均会被阻塞。&lt;/p&gt;
&lt;p&gt;多线程下应该使用主键来修改数据降低阻塞的概率。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;update/delete&lt;/code&gt;的where条件没有使用索引或者没有where条件，就会全表扫描，会对所有记录加上next-key锁（&lt;code&gt;record锁+gap锁&lt;/code&gt;）,相当于把整张表锁住了&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySQL删除修改数据优化</title>
        <link>https://rusthx.github.io/p/mysql%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96/</link>
        <pubDate>Thu, 12 Sep 2024 22:15:33 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/mysql%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h2 id=&#34;删除&#34;&gt;删除
&lt;/h2&gt;&lt;h3 id=&#34;删除未在他表出现的数据&#34;&gt;删除未在他表出现的数据
&lt;/h3&gt;&lt;p&gt;下面有一条效率较差的删除语句，主要功能是将t1表中id未出现在t2表的记录删除。效率差的原因是in中用了子查询，导致删除语句不会走索引，从而导致锁全表，继而导致删除效率差。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;delete from t1 
  where id not in 
  (
    select id from t2
  )

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优化方法:取消子查询，改用关联删除，这样就可以使用建在id列上的索引。关联删除/更新在建立索引的情况下效率远高于&lt;code&gt;in/exists&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优化后的SQL语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;delete t1 
  from t1 left join t2 on t1.id=t2.id
  where t2.id is null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：上面这条是MySQL独有的优化，达梦数据库和Oracle中可用如下语句。（拾人牙慧，未经验证，用这两个数据库的朋友可以自行验证一下）&lt;code&gt;(+)&lt;/code&gt;表示单侧关联，该符号在哪边哪边就是副表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQl&#34;&gt;delete from t1
  where rowid in(
    select t1.rowid 
      from t1,t2
      where t2.id(+)=t1.id and t2.id is null
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除多表相同数据&#34;&gt;删除多表相同数据
&lt;/h3&gt;&lt;p&gt;好的删除语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQl&#34;&gt;delete t1,t2
  from t1,t2
  where t1.id=t2.id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以同时删除从主从表删除。比如一条记录记录在多张表中，删除这条记录需要同时删除两张表的记录。这样可以保证要么全部删除，要么全部不删，间接满足了事务一致性。（数据库只会从一个状态转移至另外一个状态，即拥有这条记录和没有这条记录的两个状态。这一条记录可以看成是一个入库记录、一张支票）&lt;/p&gt;
&lt;h3 id=&#34;删除全表数据&#34;&gt;删除全表数据
&lt;/h3&gt;&lt;p&gt;用truncate替代delete。这里涉及delete的机制，delete并不是直接在磁盘中删除记录，而是将记录加一个标记，并设置为不可见，然后在数据库压力小时异步删除磁盘中的数据。但是这样有一个问题，虽然标记为删除后，查询表记录不可见。但是记录仍然占有着磁盘空间，这会拖慢查询数据库的速度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;truncate table t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新
&lt;/h2&gt;&lt;p&gt;差的更新语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;update t1
  set c1=&#39;&#39;
  where id in (...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如删除篇中所说，由于in中属性过多，in不会再走索引（当属性值大于4个后就不会再走索引，in中是子查询的话就不会走索引）。所以这里的更新效率慢，并且还会锁住整表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于为什么全表扫描会锁住整张表可以看小林的教程：&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/lock/update_index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;update 没加索引会锁全表？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优化方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建id临时表，临时表只有id一个字段&lt;/li&gt;
&lt;li&gt;批量插入临时表，记录为上面差的更新语句中的记录，也即是需要更新的记录的id&lt;/li&gt;
&lt;li&gt;将临时表于原表关联更新&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;补充插入更新&#34;&gt;补充：插入更新
&lt;/h2&gt;&lt;p&gt;插入一条数据，如果存在主键或唯一键冲突，则更新记录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：使用此语句时，必须在表中定义主键或唯一约束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into [table_name] (column1,column2,column3...)
  values (values1,values2,values3...)
  on duplicate key update
  column1 = values(column1),
  column2 = values(column2),...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`)
  values (1,&#39;Alice&#39;)
  on duplicate key update
  name = values(`name`)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PostgreSQL中用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`)
  values (1,&#39;Alice&#39;)
  on conflicate (id) do 
  update set name = excluded.name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想同时修改多个字段也可用下面的写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`，age)
  values (1,&#39;Alice&#39;,18)
  on conflicate (id) do 
  update set (`name`,age) = excluded.(`name`,age)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想遇见冲突主键不做处理可用如下语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`)
  values (1,&#39;Alice&#39;)
  on conflicate (id) do 
  nothing
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>SQL计算时间交集</title>
        <link>https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/</link>
        <pubDate>Sun, 08 Sep 2024 10:15:20 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;参考资料：《SQL进阶》P106 (鹿书)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关系表结构&#34;&gt;关系（表）结构
&lt;/h2&gt;&lt;p&gt;现有一张住宿表(&lt;code&gt;stay_people&lt;/code&gt;)如下&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;guest(入住客人)&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;start_date(入住时间)&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;end_date(退房时间)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阿良良木历&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-26&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-27&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阿良良木月火&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-28&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-31&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阿良良木火怜&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-31&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;忍野忍&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-29&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;忍野扇&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-28&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-02&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;战场原黑仪&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-28&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-30&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;千石抚子&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-30&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-02&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;问题：判断这些客人住店时间存在重叠，如果存在重叠，则展示客人的名字、入住时间和退房时间&lt;/p&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析
&lt;/h2&gt;&lt;p&gt;很明显这道题的重点是判断两个时间段是否相交，那么时间相交有如下三种情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/1.png&#34;
	width=&#34;721&#34;
	height=&#34;497&#34;
	srcset=&#34;https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/1_hu17515716768174378448.png 480w, https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/1_hu11644942538632735057.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;348px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;答案&#34;&gt;答案
&lt;/h2&gt;&lt;p&gt;1.自关联然后判断是否为三种情况之一，如果符合一种，那么时间相交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.guest
       ,t1.start_date
       ,t2.start_date
  from stay_people t1,stay_people t2
  where (t1.start_date&amp;lt;=t2.end_date and t1.start_date&amp;gt;=t2.start_date)
        or (t1.end_date&amp;gt;=t2.start_date and t1.start_date&amp;lt;=t2.start_date)
        or (t1.start_date&amp;gt;=t2.start_date and t1.end_date&amp;lt;=t2.end_date)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.比较自关联后一行的最小的end_date和最大的start_date来判断两个时间段是否相交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.guest
       ,t1.start_date
       ,t2.start_date
  from stay_people t1,stay_people t2
  where greatest(t1.start_date,t2.start_date)&amp;lt;=least(t1.end_date,t2.end_date)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 使用数据库的内置函数判断时间段是否相交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.guest
       ,t1.start_date
       ,t2.start_date
  from stay_people t1,stay_people t2
  where (t1.start_date,t1.end_date) overlaps (t2.start_date,t2.end_date)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，这种判断默认的时间段是左闭右开的，即认为住宿时间为&lt;code&gt;[start_date,end_date)&lt;/code&gt;,并且这个函数只有SQL Server、PostgreSQL、Oracle支持，MySQL并不支持这种写法。未列举的数据库不一定不支持，可以查一下相关文档&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.postgres.cn/docs/9.3/functions-datetime.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PostgreSQL时间函数文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我写的只是三种类型的处理方法，除了我的写法，还有许多别的写法，我只是做一个简单总结&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Scala连接MySQL和Hive</title>
        <link>https://rusthx.github.io/p/scala%E8%BF%9E%E6%8E%A5mysql%E5%92%8Chive/</link>
        <pubDate>Sat, 07 Sep 2024 11:47:55 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/scala%E8%BF%9E%E6%8E%A5mysql%E5%92%8Chive/</guid>
        <description>&lt;h2 id=&#34;连接mysql&#34;&gt;连接MySQL
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Jaryer/p/13671449.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Jaryer/p/13671449.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;maven添加依赖&#34;&gt;maven添加依赖
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.mysql&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mysql-connector-j&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;8.0.33&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;连接数据库&#34;&gt;连接数据库
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val host = &amp;quot;localhost&amp;quot;
val port = 3306
val database = &amp;quot;sparktest&amp;quot;
val jdbcUrl = s&amp;quot;jdbc:mysql://$host:$port/$database?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;quot;
val mysqlConn: Connection = DriverManager.getConnection(jdbcUrl, &amp;quot;root&amp;quot;, &amp;quot;123456&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;执行查询&#34;&gt;执行查询
&lt;/h3&gt;&lt;p&gt;SQL语句在执行时有三种：&lt;code&gt;executeQuery&lt;/code&gt;,&lt;code&gt;executeUpdate&lt;/code&gt;,&lt;code&gt;execute&lt;/code&gt;。具体细节可查看此节开头的参考资料。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;    val statement: Statement = mysqlConn.createStatement()
    //插入数据
    statement.executeUpdate(&amp;quot;insert into employee values (3,&#39;Mary&#39;,&#39;F&#39;,26)&amp;quot;)
    statement.executeUpdate(&amp;quot;insert into employee values (4,&#39;Tom&#39;,&#39;M&#39;,23)&amp;quot;)

    val result: ResultSet = statement.executeQuery(&amp;quot;select max(age) as max_age,avg(age) as avg_age from employee&amp;quot;)
    while (result.next()) {
      println(result.getString(&amp;quot;max_age&amp;quot;),result.getString(&amp;quot;avg_age&amp;quot;))
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码&#34;&gt;完整代码
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package sparkjob5

import java.sql.{Connection, DriverManager, ResultSet, Statement}

object task3 {
  def main(args: Array[String]): Unit = {
    //连接mysql
    val host = &amp;quot;localhost&amp;quot;
    val port = 3306
    val database = &amp;quot;sparktest&amp;quot;
    val jdbcUrl = s&amp;quot;jdbc:mysql://$host:$port/$database?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;quot;
    val mysqlConn: Connection = DriverManager.getConnection(jdbcUrl, &amp;quot;root&amp;quot;, &amp;quot;123456&amp;quot;)

    val statement: Statement = mysqlConn.createStatement()
    //插入数据
    statement.executeUpdate(&amp;quot;insert into employee values (3,&#39;Mary&#39;,&#39;F&#39;,26)&amp;quot;)
    statement.executeUpdate(&amp;quot;insert into employee values (4,&#39;Tom&#39;,&#39;M&#39;,23)&amp;quot;)

    val result: ResultSet = statement.executeQuery(&amp;quot;select max(age) as max_age,avg(age) as avg_age from employee&amp;quot;)
    while (result.next()) {
      println(result.getString(&amp;quot;max_age&amp;quot;),result.getString(&amp;quot;avg_age&amp;quot;))
    }

    result.close()
    statement.close()
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;连接hive&#34;&gt;连接Hive
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/27a798013990&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/27a798013990&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;连接Hive前需要开启Hive的metastore和hiverserver2。开启命令如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启Hadoop集群&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;start-all.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;开启Hive,第二三行的启动命令需要分别开一个终端启动，输出的日志在&lt;code&gt;/usr/local/hive/logs&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/hive
hive --service metastore &amp;gt;logs/metastore.log 2&amp;gt;&amp;amp;1
hive --service hiveserver2 &amp;gt;logs/hiveServer2.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加依赖&#34;&gt;添加依赖
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spark-hive_2.12&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.3.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;hadoop-client&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.3.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.hive&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;hive-jdbc&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.1.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整依赖如下（包含了Scala连接MySQL的依赖）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;artifactId&amp;gt;Spark&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;artifactId&amp;gt;sparkCore&amp;lt;/artifactId&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spark-core_2.12&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spark-sql_2.12&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.0.33&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spark-hive_2.12&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;hadoop-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.hive&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;hive-jdbc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.1.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;17&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;17&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- 该插件用于将 Scala 代码编译成 class 文件 --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;net.alchim31.maven&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;scala-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;!-- 声明绑定到 maven 的 compile 阶段 --&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;descriptorRefs&amp;gt;
                        &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;
                    &amp;lt;/descriptorRefs&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改配置文件hive-sitexml&#34;&gt;修改配置文件hive-site.xml
&lt;/h3&gt;&lt;p&gt;在resource下新建一个&lt;code&gt;hive-site.xml&lt;/code&gt;，填入下列内容。注意：要把&lt;code&gt;hadoop1&lt;/code&gt;修改成自己的Hadoop集群主节点名字或者ip。
&lt;img src=&#34;https://rusthx.github.io/p/scala%E8%BF%9E%E6%8E%A5mysql%E5%92%8Chive/1.png&#34;
	width=&#34;1261&#34;
	height=&#34;798&#34;
	srcset=&#34;https://rusthx.github.io/p/scala%E8%BF%9E%E6%8E%A5mysql%E5%92%8Chive/1_hu6304836396205212170.png 480w, https://rusthx.github.io/p/scala%E8%BF%9E%E6%8E%A5mysql%E5%92%8Chive/1_hu6195403910822788867.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;379px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;?xml-stylesheet type=&amp;quot;text/xsl&amp;quot; href=&amp;quot;configuration.xsl&amp;quot;?&amp;gt;

&amp;lt;configuration&amp;gt;
    &amp;lt;!-- 添加文件调用 --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.exec.scratchdir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hdfs://hadoop1:8020/user/hive/tmp&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.metastore.warehouse.dir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hdfs://hadoop1:8020/user/hive/warehouse&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.querylog.location&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hdfs://hadoop1:8020/user/hive/log&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- 指定存储元数据要连接的地址 --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.metastore.uris&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;thrift://hadoop1:9083&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!-- jdbc连接的URL --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;javax.jdo.option.ConnectionURL&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;jdbc:mysql://hadoop1:3306/metastore?useUnicode=true&amp;amp;amp;characterEncodeing=UTF-8&amp;amp;amp;allowPublicKeyRetrieval=true&amp;amp;amp;useSSL=false&amp;amp;amp;serverTimezone=GMT&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!-- jdbc连接的Driver--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;javax.jdo.option.ConnectionDriverName&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;com.mysql.jdbc.Driver&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!-- jdbc连接的username--&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;javax.jdo.option.ConnectionUserName&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hive&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!-- jdbc连接的password --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;javax.jdo.option.ConnectionPassword&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;123456&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;


    &amp;lt;!-- 指定hiveserver2连接的host --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.server2.thrift.bind.host&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;hadoop1&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!-- 指定hiveserver2连接的端口号 --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.server2.thrift.port&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;10000&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;!-- hiveserver2的高可用参数，开启此参数可以提高hiveserver2的启动速度 --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hive.server2.active.passive.ha.enable&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;scala代码&#34;&gt;Scala代码
&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;spark.sql()&lt;/code&gt;里写上正常的SQL语句即可完成查询。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package sparkjob5


import org.apache.spark.SparkConf
import org.apache.spark.sql.SparkSession


object task4 {
  val driverName = &amp;quot;org.apache.hive.jdbc.HiveDriver&amp;quot;
  try {
    Class.forName(driverName)
  } catch {
    case e: ClassNotFoundException =&amp;gt;
    println(&amp;quot;Missing Class&amp;quot;, e)
  }

  def main(args: Array[String]): Unit = {
    val conf = new SparkConf().setMaster(&amp;quot;local[3]&amp;quot;).setAppName(&amp;quot;hive&amp;quot;)
    val spark = SparkSession.builder().config(conf).enableHiveSupport().getOrCreate()

    spark.sql(&amp;quot;use spark_test&amp;quot;)
    spark.sql(&amp;quot;show tables&amp;quot;).show()
    spark.close()
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充：将查询结果保存到hdfs上，如果想保存到本地，则可以将save的路径改成本地路径。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;    val dataFrame = spark.sql(&amp;quot;select uid,keyword from sougou_records where keyword like &#39;%仙剑奇侠传%&#39;&amp;quot;)

    dataFrame.write
      .format(&amp;quot;csv&amp;quot;)
      .option(&amp;quot;header&amp;quot;, &amp;quot;false&amp;quot;)
      .option(&amp;quot;sep&amp;quot;, &amp;quot;\t&amp;quot;)
      .save(&amp;quot;hdfs://hadoop1:8020/xianJianTest&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想以表格保存到MySQL或者Hive,可以使用&lt;code&gt;saveAsTable()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val host = &amp;quot;localhost&amp;quot;
val port = 3306
val database = &amp;quot;sparktest&amp;quot;
val jdbcUrl = s&amp;quot;jdbc:mysql://$host:$port/$database?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;quot;
val connectionProperties = new java.util.Properties()
connectionProperties.put(&amp;quot;user&amp;quot;, &amp;quot;root&amp;quot;)
connectionProperties.put(&amp;quot;password&amp;quot;, &amp;quot;123456&amp;quot;)

df.write.mode(SaveMode.Overwrite).jdbc(jdbcUrl,&amp;quot;company&amp;quot;,connectionProperties)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;df.write.mode(SaveMode.Overwrite).saveAsTable(&amp;quot;spark_test.company&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Ubuntu22.04安装MySQL8.0.35</title>
        <link>https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/</link>
        <pubDate>Wed, 04 Sep 2024 23:18:48 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/</guid>
        <description>&lt;h2 id=&#34;更新软件包&#34;&gt;更新软件包
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get update 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/1.png&#34;
	width=&#34;874&#34;
	height=&#34;281&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/1_hu10208442681550117401.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/1_hu1540946352521276743.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;311&#34;
		data-flex-basis=&#34;746px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;下载mysql&#34;&gt;下载MySQL
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/2.png&#34;
	width=&#34;715&#34;
	height=&#34;471&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/2_hu3499638476653893172.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/2_hu13321327387705561269.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;151&#34;
		data-flex-basis=&#34;364px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;登入mysql&#34;&gt;登入MySQL
&lt;/h2&gt;&lt;p&gt;MySQL安装完成后会有默认用户和密码，通过默认的用户和密码登入MySQL后可以新建用户并对该用户赋权&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看默认用户和密码的命令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo cat /etc/mysql/debian.cnf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/3.png&#34;
	width=&#34;645&#34;
	height=&#34;318&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/3_hu6395335293921905352.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/3_hu3445967368468062197.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;202&#34;
		data-flex-basis=&#34;486px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用默认用户和密码登入数据库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mysql -u用户名 -p
输入密码
用户名和密码分别为上图中的user 和password&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -udebian-sys-maint -p

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/4.png&#34;
	width=&#34;772&#34;
	height=&#34;401&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/4_hu13038779922474440114.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/4_hu1796599610772816749.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;462px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;新建用户-设置密码-赋权&#34;&gt;新建用户 设置密码 赋权
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;设置root用户的密码（我的密码设置为123456，根据自己的需求修改命令）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;use mysql;
update user set authentication_string=&#39;&#39; where user=&#39;root&#39;;
alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;123456&#39;;
quit;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/5.png&#34;
	width=&#34;848&#34;
	height=&#34;578&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/5_hu13115251342486511113.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/5_hu4830470020606109148.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;352px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用root用户登入数据库，并新建用户和赋权&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图为查询用户密码（加密过的）的命令
&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/6.png&#34;
	width=&#34;1191&#34;
	height=&#34;500&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/6_hu4511073906702965881.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/6_hu14249002274118037829.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;238&#34;
		data-flex-basis=&#34;571px&#34;
	
&gt;
下列命令的意思是：
创建用户rust 并设置rust用户可以访问的位置为%（本地访问和远程访问，仅本地访问为localhost）
复制所有数据库的所有权限给rust用户
刷新权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE USER &#39;rust&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;
GRANT ALL PRIVILEGES ON *.* TO &#39;rust&#39;@&#39;%&#39; WITH GRANT OPTION;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;设置mysql数据库允许远程访问&#34;&gt;设置MySQL数据库允许远程访问
&lt;/h2&gt;&lt;p&gt;默认情况下，MySQL服务器只允许本地连接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑MySQL配置文件（/etc/mysql/mysql.conf.d/mysqld.cnf）并注释掉以下行（在 bind-address 行前面添加#）：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/7.png&#34;
	width=&#34;904&#34;
	height=&#34;788&#34;
	srcset=&#34;https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/7_hu11885888147539780446.png 480w, https://rusthx.github.io/p/ubuntu22.04%E5%AE%89%E8%A3%85mysql8.0.35/7_hu2354824758386346848.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;114&#34;
		data-flex-basis=&#34;275px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;保存文件并重启MySQL服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl restart mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mysql执行顺序&#34;&gt;MySQL执行顺序
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/Elsa15/article/details/108544943&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/Elsa15/article/details/108544943&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;(9) SELECT (10)DISTINCT column,(6) AGG_FUNC(column or expression),...
(1）FROM left_table
(3）J0IN right_table
(2） ON tablename.column =
 other_tablename.column
 (4）WHERE constraint_expression(5)GROUP BY column
(7)WITH CUBE | ROLLUP
(8)HAVING constraint_expression(11)ORDER BY column ASCIDEsc
(12)LIMIT count OFFSET count;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
