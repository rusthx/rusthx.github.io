<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>SQL on rustWood</title>
        <link>https://rusthx.github.io/tags/sql/</link>
        <description>Recent content in SQL on rustWood</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>rustWood</copyright>
        <lastBuildDate>Sat, 14 Sep 2024 17:49:28 +0800</lastBuildDate><atom:link href="https://rusthx.github.io/tags/sql/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>数据库实现树状（层级）结构</title>
        <link>https://rusthx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%8A%B6%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <pubDate>Sat, 14 Sep 2024 17:49:28 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%8A%B6%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;问题&#34;&gt;问题
&lt;/h2&gt;&lt;p&gt;有一张交易流水表（transaction），主键为账号，每个账号有所属公司。有一张公司信息表（company_info），主键为公司id，表中有上级公司id。&lt;/p&gt;
&lt;p&gt;需要得到每个公司的交易信息（资金流入流出余额），但是每个公司的数据都应该是该公司及下属公司的汇总。
但是数据库并不支持树形结构也不支持层级结构。&lt;/p&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案
&lt;/h2&gt;&lt;p&gt;主要难题在于公司信息表，公司只有上面一级的信息，没有更上面的信息，也没有下属公司信息。&lt;/p&gt;
&lt;p&gt;所以需要做一张公司树表（company_tree），记录上下关系和层级信息，加工方案如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置字段为公司id，公司id树（从最顶层公司到当前公司，类似&#39;0011-0022&amp;rsquo;），公司层级,上级公司id(sup_comp_id)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入最顶层公司信息（&amp;lsquo;0011&amp;rsquo;）,设置该公司层级为1级。id树为&#39;0011&amp;rsquo;
然后查询company_info表，插入上级为（&amp;lsquo;0011&amp;rsquo;）的公司信息，设置层级为2级，拼接上级公司id树(&amp;lsquo;0011&amp;rsquo;)和当前公司id作为当前公司的id树。
然后插入三级公司、四级公司，直到最底层公司。不知道到底有多少层可以插入一层后观察company_tree表有无新增数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：三级及更下级的公司需要冗余多行，每行的上级公司id不同（分别为顶级到当前公司的父级公司的公司id）&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;关联company_tree表和transaction,group by sup_comp_id,再对资金流入流出余额进行sum()聚合。
这里加一个按层级的过滤条件，一层一层给地查，然后再union查询结果即可得到所有公司的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;观察上面的方案不难发现，这张加工的company_tree不好用，公司信息比较少变（除了股市），一般都是作为数仓的维度表。
但是每次需要关联查询company_tree时写的查询语句都很复杂，那么怎样才能不用union各层公司信息呢？&lt;/p&gt;
&lt;p&gt;设计company_tree的时候再加一个up_comp_tree字段。这样聚合的时候group by up_comp_tree就能拿到所有公司的汇总信息。
（因为公司的下属公司的所有下一级公司的up_comp_tree都是当前公司的id树）&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySQL删除修改数据优化</title>
        <link>https://rusthx.github.io/p/mysql%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96/</link>
        <pubDate>Thu, 12 Sep 2024 22:15:33 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/mysql%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h2 id=&#34;删除&#34;&gt;删除
&lt;/h2&gt;&lt;h3 id=&#34;删除未在他表出现的数据&#34;&gt;删除未在他表出现的数据
&lt;/h3&gt;&lt;p&gt;下面有一条效率较差的删除语句，主要功能是将t1表中id未出现在t2表的记录删除。效率差的原因是in中用了子查询，导致删除语句不会走索引，从而导致锁全表，继而导致删除效率差。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;delete from t1 
  where id not in 
  (
    select id from t2
  )

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优化方法:取消子查询，改用关联删除，这样就可以使用建在id列上的索引。关联删除/更新在建立索引的情况下效率远高于&lt;code&gt;in/exists&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优化后的SQL语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;delete t1 
  from t1 left join t2 on t1.id=t2.id
  where t2.id is null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：上面这条是MySQL独有的优化，达梦数据库和Oracle中可用如下语句。（拾人牙慧，未经验证，用这两个数据库的朋友可以自行验证一下）&lt;code&gt;(+)&lt;/code&gt;表示单侧关联，该符号在哪边哪边就是副表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQl&#34;&gt;delete from t1
  where rowid in(
    select t1.rowid 
      from t1,t2
      where t2.id(+)=t1.id and t2.id is null
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除多表相同数据&#34;&gt;删除多表相同数据
&lt;/h3&gt;&lt;p&gt;好的删除语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQl&#34;&gt;delete t1,t2
  from t1,t2
  where t1.id=t2.id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以同时删除从主从表删除。比如一条记录记录在多张表中，删除这条记录需要同时删除两张表的记录。这样可以保证要么全部删除，要么全部不删，间接满足了事务一致性。（数据库只会从一个状态转移至另外一个状态，即拥有这条记录和没有这条记录的两个状态。这一条记录可以看成是一个入库记录、一张支票）&lt;/p&gt;
&lt;h3 id=&#34;删除全表数据&#34;&gt;删除全表数据
&lt;/h3&gt;&lt;p&gt;用truncate替代delete。这里涉及delete的机制，delete并不是直接在磁盘中删除记录，而是将记录加一个标记，并设置为不可见，然后在数据库压力小时异步删除磁盘中的数据。但是这样有一个问题，虽然标记为删除后，查询表记录不可见。但是记录仍然占有着磁盘空间，这会拖慢查询数据库的速度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;truncate table t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新
&lt;/h2&gt;&lt;p&gt;差的更新语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;update t1
  set c1=&#39;&#39;
  where id in (...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如删除篇中所说，由于in中属性过多，in不会再走索引（当属性值大于4个后就不会再走索引，in中是子查询的话就不会走索引）。所以这里的更新效率慢，并且还会锁住整表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于为什么全表扫描会锁住整张表可以看小林的教程：&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/lock/update_index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;update 没加索引会锁全表？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优化方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建id临时表，临时表只有id一个字段&lt;/li&gt;
&lt;li&gt;批量插入临时表，记录为上面差的更新语句中的记录，也即是需要更新的记录的id&lt;/li&gt;
&lt;li&gt;将临时表于原表关联更新&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;补充插入更新&#34;&gt;补充：插入更新
&lt;/h2&gt;&lt;p&gt;插入一条数据，如果存在主键或唯一键冲突，则更新记录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：使用此语句时，必须在表中定义主键或唯一约束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into [table_name] (column1,column2,column3...)
  values (values1,values2,values3...)
  on duplicate key update
  column1 = values(column1),
  column2 = values(column2),...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`)
  values (1,&#39;Alice&#39;)
  on duplicate key update
  name = values(`name`)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PostgreSQL中用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`)
  values (1,&#39;Alice&#39;)
  on conflicate (id) do 
  update set name = excluded.name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想同时修改多个字段也可用下面的写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`，age)
  values (1,&#39;Alice&#39;,18)
  on conflicate (id) do 
  update set (`name`,age) = excluded.(`name`,age)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想遇见冲突主键不做处理可用如下语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;insert into users (id,`name`)
  values (1,&#39;Alice&#39;)
  on conflicate (id) do 
  nothing
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>SQL计算时间交集</title>
        <link>https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/</link>
        <pubDate>Sun, 08 Sep 2024 10:15:20 +0800</pubDate>
        
        <guid>https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;参考资料：《SQL进阶》P106 (鹿书)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关系表结构&#34;&gt;关系（表）结构
&lt;/h2&gt;&lt;p&gt;现有一张住宿表(&lt;code&gt;stay_people&lt;/code&gt;)如下&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;guest(入住客人)&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;start_date(入住时间)&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;end_date(退房时间)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阿良良木历&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-26&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-27&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阿良良木月火&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-28&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-31&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阿良良木火怜&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-31&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;忍野忍&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-29&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-01&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;忍野扇&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-28&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-02&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;战场原黑仪&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-28&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-30&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;千石抚子&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-10-30&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2006-11-02&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;问题：判断这些客人住店时间存在重叠，如果存在重叠，则展示客人的名字、入住时间和退房时间&lt;/p&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析
&lt;/h2&gt;&lt;p&gt;很明显这道题的重点是判断两个时间段是否相交，那么时间相交有如下三种情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/1.png&#34;
	width=&#34;721&#34;
	height=&#34;497&#34;
	srcset=&#34;https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/1_hu17515716768174378448.png 480w, https://rusthx.github.io/p/sql%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%BA%A4%E9%9B%86/1_hu11644942538632735057.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;348px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;答案&#34;&gt;答案
&lt;/h2&gt;&lt;p&gt;1.自关联然后判断是否为三种情况之一，如果符合一种，那么时间相交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.guest
       ,t1.start_date
       ,t2.start_date
  from stay_people t1,stay_people t2
  where (t1.start_date&amp;lt;=t2.end_date and t1.start_date&amp;gt;=t2.start_date)
        or (t1.end_date&amp;gt;=t2.start_date and t1.start_date&amp;lt;=t2.start_date)
        or (t1.start_date&amp;gt;=t2.start_date and t1.end_date&amp;lt;=t2.end_date)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.比较自关联后一行的最小的end_date和最大的start_date来判断两个时间段是否相交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.guest
       ,t1.start_date
       ,t2.start_date
  from stay_people t1,stay_people t2
  where greatest(t1.start_date,t2.start_date)&amp;lt;=least(t1.end_date,t2.end_date)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 使用数据库的内置函数判断时间段是否相交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.guest
       ,t1.start_date
       ,t2.start_date
  from stay_people t1,stay_people t2
  where (t1.start_date,t1.end_date) overlaps (t2.start_date,t2.end_date)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，这种判断默认的时间段是左闭右开的，即认为住宿时间为&lt;code&gt;[start_date,end_date)&lt;/code&gt;,并且这个函数只有SQL Server、PostgreSQL、Oracle支持，MySQL并不支持这种写法。未列举的数据库不一定不支持，可以查一下相关文档&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.postgres.cn/docs/9.3/functions-datetime.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PostgreSQL时间函数文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我写的只是三种类型的处理方法，除了我的写法，还有许多别的写法，我只是做一个简单总结&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
